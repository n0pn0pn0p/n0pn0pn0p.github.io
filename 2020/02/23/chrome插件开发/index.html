<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author"><title>浏览器插件 · yogurt</title><meta name="description" content="chrome插件开发参考文档：入门：建立 Chrome 扩展程序 - Google Chrome 扩展程序开发文档（非官方中文版）GitHub - sxei/chrome-plugin-demo: 《Chrome插件开发全攻略》配套完整Demo，欢迎clone体验
简介  年前因为公司一个项目接触了"><meta name="keywords"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><meta name="generator" content="Hexo 5.4.0"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">yogurt</a></h3></div></div><ul class="social-links"></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a target="_blank" rel="noopener" href="https://www.caicai.me"> CaiCai </a><span>&</span><a target="_blank" rel="noopener" href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">Home</a></li><li><a href="/about">Sobre</a></li><li><a href="/archives">Arquivo</a></li><li><a href="/links">Links</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>浏览器插件</a></h3></div><div class="post-content"><h2 id="chrome插件开发"><a href="#chrome插件开发" class="headerlink" title="chrome插件开发"></a>chrome插件开发</h2><p>参考文档：<br><a target="_blank" rel="noopener" href="https://crxdoc-zh.appspot.com/extensions/getstarted">入门：建立 Chrome 扩展程序 - Google Chrome 扩展程序开发文档（非官方中文版）</a><br><a target="_blank" rel="noopener" href="https://github.com/sxei/chrome-plugin-demo">GitHub - sxei/chrome-plugin-demo: 《Chrome插件开发全攻略》配套完整Demo，欢迎clone体验</a></p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>  年前因为公司一个项目接触了浏览器插件的开发，其实在这之前大学的时候在加密网盘项目中也接触过浏览器插件的开发，但是那时候只写了一个popup页面。<br>  Chrome插件是一个用Web技术开发、用来增强浏览器功能的软件,Chrome浏览器扩展开发算是相当简单的，基本只要掌握HTML+CSS+Javascript，即可快速开发一个属于你的Chrome插件！它其实就是一个由HTML、CSS、JS、图片等资源组成的一个.crx后缀的压缩包.</p>
<h3 id="核心部分"><a href="#核心部分" class="headerlink" title="核心部分"></a>核心部分</h3><ul>
<li><p>manifest<br>插件的入口。配置了整个插件所需要用到的东西，例如插件的名称和图标，插件的动作，和对应动作的执行的js文件等等。<br>代码示例：<a target="_blank" rel="noopener" href="https://developer.chrome.com/extensions/manifest">Manifest File Format - Google Chrome</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> //必选</span><br><span class="line"> /*</span><br><span class="line">   指定您的应用包要求的清单文件格式的版本。从 Chrome 18 开始，开发人员应该指定 2</span><br><span class="line"> */</span><br><span class="line"> &quot;manifest_version&quot;: 2,</span><br><span class="line"> &quot;name&quot;:&quot;我的应用名称&quot;,</span><br><span class="line"> &quot;version&quot;:&quot;我的应用版本&quot;,</span><br><span class="line"></span><br><span class="line"> //推荐</span><br><span class="line"> /*</span><br><span class="line">   清单文件-默认语言 指定_locales中的子目录，包含该应用默认字符串。</span><br><span class="line">   对于含有 _locales 目录的应用来说这一属性是必需的，</span><br><span class="line">   在没有 _locales 目录的应用中该属性不能存在</span><br><span class="line"> */</span><br><span class="line"> &quot;default_locale&quot;:&quot;en&quot;, </span><br><span class="line"></span><br><span class="line"> /*</span><br><span class="line">   这个描述在安装应用之后可以看见</span><br><span class="line"> */</span><br><span class="line"> &quot;description&quot;:&quot;关于应用的描述&quot;, </span><br><span class="line"></span><br><span class="line"> /*一个或多个代表应用、应用或主题背景的图标*/</span><br><span class="line"> &quot;icons&quot;:&#123;</span><br><span class="line">   &quot;16&quot;:&quot;icon16.png&quot;,</span><br><span class="line">   &quot;48&quot;:&quot;icon48.png&quot;</span><br><span class="line"> &#125;,</span><br><span class="line"></span><br><span class="line"> /*</span><br><span class="line">  选择某一个（或者无）</span><br><span class="line">  browser_action（浏览器按钮）</span><br><span class="line">  page_action（页面按钮）</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line"> // 如果有 browser_action, 即在 chrome toolbar 的右边添加了一个 icon</span><br><span class="line"> &quot;browser_action&quot;: &#123;</span><br><span class="line">   &quot;default_icon&quot;: &quot;advicedog.jpg&quot;,</span><br><span class="line">   &quot;default_title&quot;: &quot;Google Mail&quot;,      // tooltip, 光标停留在 icon 上时显示</span><br><span class="line">   &quot;default_popup&quot;: &quot;popup.html&quot;  // 如果有 popup 的页面, 则用户点击图标就会渲染此 HTML 页面</span><br><span class="line"> &#125;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> // 如果并不是对每个网站页面都需要使用插件, 可以使用 page_action(页面按钮） 而不是 browser_action（浏览器按钮）</span><br><span class="line"> // browser_action 应用更加广泛</span><br><span class="line"> // 如果 page_action 并不应用在当前页面, 会显示灰色</span><br><span class="line"></span><br><span class="line"> &quot;page_action&quot;:&#123;</span><br><span class="line">   &quot;default_icon&quot;: &#123;                    // 可选</span><br><span class="line">     &quot;19&quot;: &quot;images/icon19.png&quot;,           // 可选</span><br><span class="line">     &quot;38&quot;: &quot;images/icon38.png&quot;            // 可选</span><br><span class="line">   &#125;,</span><br><span class="line">   &quot;default_title&quot;: &quot;Google Mail&quot;,      // 可选，在工具提示中显示</span><br><span class="line">   &quot;default_popup&quot;: &quot;popup.html&quot;        // 可选</span><br><span class="line"> &#125;,</span><br><span class="line"></span><br><span class="line"> //可选</span><br><span class="line"> &quot;author&quot;:&quot;开发者&quot;,</span><br><span class="line"> &quot;automation&quot;:&quot;&quot;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> /*</span><br><span class="line"> 后台网页</span><br><span class="line"> 1.应用通常需要有一个长时间运行的脚本来管理一些任务或状态，而后台网页就是为这一目的而设立。</span><br><span class="line"> 通常情况下，后台页面不需要任何 HTML 标记，这种情况下后台页面可以单独使用 JavaScript文件实现。</span><br><span class="line"> 后台页面将由应用系统生成，包含 scripts 属性中列出的每一个文件。</span><br><span class="line"></span><br><span class="line"> 2.page：如果您需要在您的后台页面中指定 HTML，您可以改用 page 属性：</span><br><span class="line"></span><br><span class="line"> 3.persistent：应用和应用通常需要长时间运行的脚本来管理某些任务或状态，这就是事件页面的作用。</span><br><span class="line"> 事件页面只在需要时加载，当事件页面不活动时就会卸载，以便释放内存和其他系统资源。</span><br><span class="line"> 如何得到事件页面 就是设置一个&quot;persistent&quot;键，如果没有设置，你将得到一个普通的后台页面。</span><br><span class="line"> */</span><br><span class="line"> &quot;background&quot;:&#123;</span><br><span class="line">   &quot;scripts&quot;:[&quot;background.js&quot;],</span><br><span class="line">   &quot;page&quot;: &quot;background.html&quot;,</span><br><span class="line">   &quot;persistent&quot;:false</span><br><span class="line"> &#125;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> /*</span><br><span class="line">   内容脚本:其实就是向你想要的网页中插入一个脚本代码，执行你想要做的事情</span><br><span class="line">   内容脚本是在网页的上下文中运行的 JavaScript 文件，</span><br><span class="line">   它们可以通过标准的文档对象模型（DOM）来获取浏览器访问的网页详情，或者作出更改。</span><br><span class="line"></span><br><span class="line">   1.run_at 可选。</span><br><span class="line">   控制 js 中的 JavaScript 文件何时插入，</span><br><span class="line">   可以为 &quot;document_start&quot;、</span><br><span class="line">   &quot;document_end&quot; 或 &quot;document_idle&quot;，默认为 &quot;document_idle&quot;。 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   1.1如果是 &quot;document_start&quot;，这些文件将在 css 中指定的文件之后，但是在所有其他 DOM 构造或脚本运行之前插入。 </span><br><span class="line"></span><br><span class="line">   1.2.如果是 &quot;document_end&quot;，文件将在 DOM 完成之后立即插入，但是在加载子资源（如图像与框架）之前插入。 </span><br><span class="line"></span><br><span class="line">   1.3.如果是 &quot;document_idle&quot;，浏览器将在 &quot;document_end&quot; 和刚发生 window.onload 事件这两个时刻之间选择合适的时候插入，</span><br><span class="line">   具体的插入时间取决于文档的复杂程度以及加载文档所花的时间，并且浏览器会尽可能地为加快页面加载速度而优化。 </span><br><span class="line"></span><br><span class="line">   2.all_frames 可选。</span><br><span class="line">   控制内容脚本运行在匹配页面的所有框架中还是仅在顶层框架中。 默认为 false，意味着仅在顶层框架中运行</span><br><span class="line"></span><br><span class="line">   content_scripts还有一些其他不是很常用的属性</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line"> &quot;content_scripts&quot;: [&#123;</span><br><span class="line">   &quot;matches&quot;: [&quot;https://*.pingan.com.cn/*&quot;], //匹配的地址网页</span><br><span class="line">   &quot;exclude_matches&quot;:[],</span><br><span class="line">   &quot;js&quot;: [&quot;jquery.js&quot;,&quot;ideacome.js&quot;], //插入的js</span><br><span class="line">   &quot;css&quot;: [&quot;mystyles.css&quot;], //css改变样式</span><br><span class="line">   &quot;run_at&quot;:&quot;document_idle&quot;,</span><br><span class="line">   &quot;all_frames&quot;: true //该匹配下面的所有窗口</span><br><span class="line"> &#125;,&#123;</span><br><span class="line">   &quot;matches&quot;: [&quot;*://*/*.png&quot;, &quot;*://*/*.jpg&quot;, &quot;*://*/*.gif&quot;, &quot;*://*/*.bmp&quot;],</span><br><span class="line">   &quot;js&quot;: [&quot;js/show-image-content-size.js&quot;] //可以针对不同的规则插入不同的内容</span><br><span class="line"> &#125;],</span><br><span class="line"></span><br><span class="line">// 普通页面能够直接访问的插件资源列表，如果不设置是无法直接访问的</span><br><span class="line">&quot;web_accessible_resources&quot;: [</span><br><span class="line">   &quot;images/*.png&quot;,</span><br><span class="line">   &quot;style/double-rainbow.css&quot;,</span><br><span class="line">   &quot;script/double-rainbow.js&quot;,</span><br><span class="line">   &quot;script/main.js&quot;,</span><br><span class="line">   &quot;templates/*&quot;</span><br><span class="line"> ],</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">  如果不是通过 chrome web store 自动更新插件</span><br><span class="line"></span><br><span class="line">   我们希望扩展能自动升级，理由和让chrome自动升级一样：修改程序bug和安全漏洞 ，增加新功能，提升性能，改善体验。</span><br><span class="line">   一个扩展的manifest文件里面必须指定一个&quot;update_url&quot;来执行升级检测。</span><br><span class="line"></span><br><span class="line">   扩展可以托管在Chrome Web Store，也可以发布到极速浏览器应用开放平台上。</span><br><span class="line">   如果托管在Chrome Web Store则update_url应该是：http://clients2.google.com/service/update2/crx    </span><br><span class="line"> **/</span><br><span class="line"> &quot;update_url&quot;: &quot;https://clients2.google.com/service/update2/crx&quot;,</span><br><span class="line"></span><br><span class="line">// 插件主页，这个很重要，不要浪费了这个免费广告位</span><br><span class="line">&quot;homepage_url&quot;: &quot;https://www.baidu.com&quot;,</span><br><span class="line"></span><br><span class="line">/*  </span><br><span class="line">   扩展或app将使用的一组权限。每个权限是一列已知字符串列表中的一个，</span><br><span class="line">   如geolocatioin或者一个匹配模式，来指定可以访问的一个或者多个主机。</span><br><span class="line">   权限可以帮助限定危险，如果你的扩展或者app被攻击。</span><br><span class="line">   一些权限在安装之前，会告知用户</span><br><span class="line"> */</span><br><span class="line"> &quot;permissions&quot;:[</span><br><span class="line">   &quot;tabs&quot;, //Required if the extension uses the chrome.tabs or chrome.windows module.</span><br><span class="line">   &quot;bookmarks&quot;, //使用chrome.bookmarks模块来创建、组织和管理书签</span><br><span class="line">   &quot;http://www.blogger.com/&quot;,    </span><br><span class="line">   &quot;http://*.google.com/&quot;,    </span><br><span class="line">   &quot;unlimitedStorage&quot;, //提供了一个无限的HTML5配额来存储客户端数据,如数据库和本地存储文件。没有这个权限,扩展仅限于5 MB的本地存储</span><br><span class="line">   &quot;history&quot; //历史记录的使用权限  chrome.history </span><br><span class="line">   &quot;notifications&quot;,//提示</span><br><span class="line">   &quot;cookies&quot;,//Required if the extension uses the chrome.cookies module.</span><br><span class="line"> ],</span><br><span class="line"></span><br><span class="line">/**开发时为扩展指定的唯一标识值。</span><br><span class="line">注意：通常您并不需要直接使用这个值，而是在您的代码中使用相对路径或者chrome.extension.getURL()得到的绝对路径。</span><br><span class="line">这个值并不是开发时显式指定的，而是Chrome在安装.crx时辅助生成的。(开发时可以通过上传扩展或者手工打包生成crx文件)。 安装完crx，在Chrome的用户数据目录下的Default/Extensions/&lt;extensionId&gt;/&lt;versionString&gt;/manifest.json文件中，您可以看到这个扩展的key。**/</span><br><span class="line"></span><br><span class="line">key:&#x27;&#x27;,</span><br><span class="line"></span><br><span class="line">&quot;commands&quot;: &#123;</span><br><span class="line">     // commands API 用来添加快捷键</span><br><span class="line">     // 需要在 background page 上添加监听器绑定 handler</span><br><span class="line">   &quot;toggle-feature-foo&quot;: &#123;</span><br><span class="line">     &quot;suggested_key&quot;: &#123;</span><br><span class="line">       &quot;default&quot;: &quot;Ctrl+Shift+Y&quot;,</span><br><span class="line">       &quot;mac&quot;: &quot;Command+Shift+Y&quot;</span><br><span class="line">     &#125;,</span><br><span class="line">     &quot;description&quot;: &quot;Toggle feature foo&quot;,</span><br><span class="line">     &quot;global&quot;: true</span><br><span class="line">       // 当 chrome 没有 focus 时也可以生效的快捷键</span><br><span class="line">       // 仅限 Ctrl+Shift+[0..9]</span><br><span class="line">   &#125;,</span><br><span class="line">   &quot;_execute_browser_action&quot;: &#123;</span><br><span class="line">     &quot;suggested_key&quot;: &#123;</span><br><span class="line">       &quot;windows&quot;: &quot;Ctrl+Shift+Y&quot;,</span><br><span class="line">       &quot;mac&quot;: &quot;Command+Shift+Y&quot;,</span><br><span class="line">       &quot;chromeos&quot;: &quot;Ctrl+Shift+U&quot;,</span><br><span class="line">       &quot;linux&quot;: &quot;Ctrl+Shift+J&quot;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   &quot;_execute_page_action&quot;: &#123;</span><br><span class="line">     &quot;suggested_key&quot;: &#123;</span><br><span class="line">       &quot;default&quot;: &quot;Ctrl+Shift+E&quot;,</span><br><span class="line">       &quot;windows&quot;: &quot;Alt+Shift+P&quot;,</span><br><span class="line">       &quot;mac&quot;: &quot;Alt+Shift+P&quot;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   ...</span><br><span class="line"> &#125;,</span><br><span class="line"> &quot;content_capabilities&quot;: ...,</span><br><span class="line"> &quot;optional_permissions&quot;: [&quot;tabs&quot;], // 其他需要的 permission, 在使用 chrome.permissions API 时用到, 并非安装插件时需要</span><br><span class="line"></span><br><span class="line"> &quot;short_name&quot;: &quot;Short Name&quot;, // 插件名字简写</span><br><span class="line"></span><br><span class="line">&quot;storage&quot;: &#123;</span><br><span class="line">   &quot;managed_schema&quot;: &quot;schema.json&quot;</span><br><span class="line"> &#125;, //  使用 storage.managed api 的话, 需要一个 schema 文件指定存储字段类型等, 类似定义数据库表的 column</span><br><span class="line"></span><br><span class="line">//还有很多其他的配置</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>background<br>字面意思，后台，可以包含一个html后台页面（可以不用）和后台执行的js脚本，它的生命周期是插件中所有类型页面中最长的，它随着浏览器的打开而打开，随着浏览器的关闭而关闭，所以通常把需要一直运行的、启动就运行的、全局的代码放在background里面。<br>background的权限非常高，几乎可以调用所有的Chrome扩展API（除了devtools），而且它可以无限制跨域，也就是可以跨域访问任何网站而无需要求对方设置CORS。<br>1.配置文件<br>  可以通过page指定一张网页，也可以通过scripts直接指定一个JS，Chrome会自动为这个JS生成一个默认的网页</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  &#123;</span><br><span class="line">  // 会一直常驻的后台JS或后台页面</span><br><span class="line">    &quot;background&quot;:</span><br><span class="line">    &#123;</span><br><span class="line">        // 2种指定方式，如果指定JS，那么会自动生成一个背景页</span><br><span class="line">        &quot;page&quot;: &quot;background.html&quot;</span><br><span class="line">        //&quot;scripts&quot;: [&quot;js/background.js&quot;]</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.运行环境（调试）<br><img src="https://raw.githubusercontent.com/n0pn0pn0p/n0pn0pn0p.github.io/master/myimages/f110b974.png" alt="f110b974.png"></p>
<p><img src="https://raw.githubusercontent.com/n0pn0pn0p/n0pn0pn0p.github.io/master/myimages/1f025365.png" alt="1f025365.png"></p>
</li>
<li><p>event-pages<br>前面提到background的生命周期很长，但是长时间的挂载后台会消耗性能，Google又弄一个event-pages，在配置文件上，它与background的唯一区别就是多了一个persistent参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;background&quot;:</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;scripts&quot;: [&quot;event-page.js&quot;],</span><br><span class="line">        &quot;persistent&quot;: false</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它的生命周期是：在被需要时加载，在空闲时被关闭，什么叫被需要时呢？比如第一次安装、插件更新、有content-script向它发送消息，等等。</p>
</li>
<li><p>popup<br>点击browser_action或者page_action图标时打开的一个小窗口网页,实际上是一个html页面(safari13后不再是html页面)，同样可以执行js脚本，但是弹窗关闭，脚本生命周期结束。<br>popup的页面可以在配置文件中通过default_popup指定，也可以在js中通过setPopup()方法指定，可以用该方法执行页面的跳转，但这种方式的页面跳转会有延迟，需要页面重新加载才会跳转，另一种跳转方法是“window.location.href=”popup.html””<br>在权限上，它和background非常类似，它们之间最大的不同是生命周期的不同。值得注意的是：popup中可以直接通过chrome.extension.getBackgroundPage()获取background的window对象，实现在<strong>popup中可以直接调用background中的方法。</strong></p>
<p>1.运行环境（调试）<br><img src="https://raw.githubusercontent.com/n0pn0pn0p/n0pn0pn0p.github.io/master/myimages/a9ef4bb9.png" alt="a9ef4bb9.png"></p>
<p><img src="https://raw.githubusercontent.com/n0pn0pn0p/n0pn0pn0p.github.io/master/myimages/ecd7615a.png" alt="ecd7615a.png"></p>
</li>
<li><p>content-scripts<br>页面内容脚本，就是通过插件向一个页面注入脚本，使得页面在加载前或者加载后等阶段执行脚本命令（虽然名为script，其实还可以包括css的）。最常见的操作：广告屏蔽、页面CSS定制，等等。<br>content-scripts和原始页面共享DOM，但是不共享JS，如要访问页面JS（例如某个JS变量），只能通过injected js来实现。content-scripts不能访问绝大部分chrome.xxx.api，除了下面这4种：</p>
<ol>
<li>chrome.extension(getURL, inIncognitoContext, lastError,onRequest,sendRequest)</li>
<li>chrome.i18n</li>
<li>chrome.runtime(connect , getManifest , getURL , id , onConnect , onMessage , sendMessage)</li>
<li>chrome.storage</li>
</ol>
<p>运行（调试）<br>浏览器F12开发者工具中进行调试即可。</p>
</li>
<li><p>injected-script<br>前面有提到，content-srcript不共享JS，如要访问页面JS（例如某个JS变量），只能通过injected js来实现。这是因为content-script有一个很大的“缺陷”，也就是无法访问页面中的JS，虽然它可以操作DOM，但是DOM却不能调用它，也就是无法在DOM中通过绑定事件的方式调用content-script中的代码（包括直接写onclick和addEventListener2种方式都不行），但是，“在页面上添加一个按钮并调用插件的扩展API”是一个很常见的需求，那该怎么办呢？<br>通过content-script向页面注入inject-js示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  function injectCustomJs(jsPath)</span><br><span class="line">&#123;</span><br><span class="line">    jsPath = jsPath || &#x27;js/inject.js&#x27;;</span><br><span class="line">    var temp = document.createElement(&#x27;script&#x27;);</span><br><span class="line">    temp.setAttribute(&#x27;type&#x27;, &#x27;text/javascript&#x27;);</span><br><span class="line">    // 获得的地址类似：chrome-extension://ihcokhadfjfchaeagdoclpnjdiokfakg/js/inject.js</span><br><span class="line">    temp.src = chrome.extension.getURL(jsPath);</span><br><span class="line">    temp.onload = function()</span><br><span class="line">    &#123;</span><br><span class="line">        // 放在页面不好看，执行完后移除掉</span><br><span class="line">        this.parentNode.removeChild(this);</span><br><span class="line">    &#125;;</span><br><span class="line">    document.body.appendChild(temp);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>manifest.json</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    // 普通页面能够直接访问的插件资源列表，如果不设置是无法直接访问的</span><br><span class="line">    &quot;web_accessible_resources&quot;: [&quot;js/inject.js&quot;],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>以上是开发一个插件的几个核心部分，除此之外，还有一些通信交互、api使用、权限等问题：</p>
<h3 id="消息通信"><a href="#消息通信" class="headerlink" title="消息通信"></a>消息通信</h3><table>
<thead>
<tr>
<th></th>
<th>injected-script</th>
<th>content-script</th>
<th>popup-js</th>
<th>background-js</th>
</tr>
</thead>
<tbody><tr>
<td>injected-script</td>
<td>-</td>
<td>window.postMessage</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>content-script</td>
<td>window.postMessage</td>
<td>-</td>
<td>chrome.runtime.sendMessage chrome.runtime.connect</td>
<td>chrome.runtime.sendMessage chrome.runtime.connect</td>
</tr>
<tr>
<td>popup-js</td>
<td>-</td>
<td>chrome.tabs.sendMessage chrome.tabs.connect</td>
<td>-</td>
<td>chrome.extension. getBackgroundPage()</td>
</tr>
<tr>
<td>background-js</td>
<td>-</td>
<td>chrome.tabs.sendMessage chrome.tabs.connect</td>
<td>chrome.extension.getViews</td>
<td>-</td>
</tr>
<tr>
<td>devtools-js</td>
<td>chrome.devtools. inspectedWindow.eval</td>
<td>-</td>
<td>chrome.runtime.sendMessage</td>
<td>chrome.runtime.sendMessage</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<ul>
<li><p>popup与background通信<br>1.上文说过，popup可以直接调用background中的JS方法，也可以直接访问background的DOM：</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> // background.js</span><br><span class="line">function test()</span><br><span class="line">&#123;</span><br><span class="line">  alert(&#x27;我是background！&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// popup.js</span><br><span class="line">var bg = chrome.extension.getBackgroundPage();</span><br><span class="line">bg.test(); // 访问bg的函数</span><br><span class="line">alert(bg.document.body.innerHTML); // 访问bg的DOM</span><br></pre></td></tr></table></figure>
<p>2.background访问popup如下（前提是popup已经打开）：</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var views = chrome.extension.getViews(&#123;type:&#x27;popup&#x27;&#125;);</span><br><span class="line">if(views.length &gt; 0) &#123;</span><br><span class="line">  console.log(views[0].location.href);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>popup或者bg与content通信</p>
<ol>
<li><p>background.js或者popup.js向content-script</p>
</li>
<li><p>background.js或者popup.js发送</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function sendMessageToContentScript(message, callback)</span><br><span class="line">&#123;</span><br><span class="line">  chrome.tabs.query(&#123;active: true, currentWindow: true&#125;, function(tabs)</span><br><span class="line">  &#123;</span><br><span class="line">    chrome.tabs.sendMessage(tabs[0].id, message, function(response)</span><br><span class="line">    &#123;</span><br><span class="line">      if(callback) callback(response);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">sendMessageToContentScript(&#123;cmd:&#x27;test&#x27;, value:&#x27;你好，我是popup！&#x27;&#125;, function(response)</span><br><span class="line">&#123;</span><br><span class="line">  console.log(&#x27;来自content的回复：&#x27;+response);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li><p>content-script.js接收</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">chrome.runtime.onMessage.addListener(function(request, sender, sendResponse)</span><br><span class="line">   &#123;</span><br><span class="line">     // console.log(sender.tab ?&quot;from a content script:&quot; + sender.tab.url :&quot;from the extension&quot;);</span><br><span class="line">     if(request.cmd == &#x27;test&#x27;) alert(request.value);</span><br><span class="line">     sendResponse(&#x27;我收到了你的消息！&#x27;);</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure>
<p>网上一些用法是<code>chrome.extension.onMessage</code>,貌似没有区别。</p>
</li>
<li><p>content-script发消息给后台</p>
</li>
<li><p>content-script.js发送</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chrome.runtime.sendMessage(&#123;greeting: &#x27;你好，我是content-script呀，我主动发消息给后台！&#x27;&#125;, function(response) &#123;</span><br><span class="line">console.log(&#x27;收到来自后台的回复：&#x27; + response);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li><p>background.js 或者 popup.js接收</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 监听来自content-script的消息</span><br><span class="line">chrome.runtime.onMessage.addListener(function(request, sender, sendResponse)</span><br><span class="line">&#123;</span><br><span class="line">  console.log(&#x27;收到来自content-script的消息：&#x27;);</span><br><span class="line">  console.log(request, sender, sendResponse);</span><br><span class="line">  sendResponse(&#x27;我是后台，我已收到你的消息：&#x27; + JSON.stringify(request));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ol>
<p>  注：<br>  1).content_scripts向popup主动发消息的前提是popup必须打开！否则需要利用background作中转；<br>  2).如果background和popup同时监听，那么它们都可以同时收到消息，但是只有一个可以sendResponse，一个先发送了，那么另外一个再发送就无效；</p>
</li>
<li><p>injected-script与content-script通信<br>content-script与injected-script之间唯一共享的是页面的DOM。有2种方法可以实现二者通讯：</p>
<ol>
<li>通过window.postMessage和window.addEventListener来实现二者消息通讯：</li>
</ol>
<ul>
<li><p>injected-script：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.postMessage(&#123;&quot;test&quot;: &#x27;你好！&#x27;&#125;, &#x27;*&#x27;);</span><br></pre></td></tr></table></figure></li>
<li><p>content script：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&quot;message&quot;, function(e)</span><br><span class="line">&#123;</span><br><span class="line">  console.log(e.data);</span><br><span class="line">&#125;, false);</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="2">
<li>通过自定义DOM事件来实现:</li>
</ol>
<ul>
<li><p>injected-script：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var customEvent = document.createEvent(&#x27;Event&#x27;);</span><br><span class="line">customEvent.initEvent(&#x27;myCustomEvent&#x27;, true, true);</span><br><span class="line">function fireCustomEvent(data) &#123;</span><br><span class="line">  hiddenDiv =document.getElementById(&#x27;myCustomEventDiv&#x27;);</span><br><span class="line">  hiddenDiv.innerText = data</span><br><span class="line">  hiddenDiv.dispatchEvent(customEvent);</span><br><span class="line">&#125;</span><br><span class="line">fireCustomEvent(&#x27;你好，我是普通JS！&#x27;);</span><br></pre></td></tr></table></figure></li>
<li><p>content script：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var hiddenDiv =</span><br><span class="line">document.getElementById(&#x27;myCustomEventDiv&#x27;);</span><br><span class="line">if(!hiddenDiv) &#123;</span><br><span class="line">  hiddenDiv = document.createElement(&#x27;div&#x27;);</span><br><span class="line">  hiddenDiv.style.display = &#x27;none&#x27;;</span><br><span class="line">  document.body.appendChild(hiddenDiv);</span><br><span class="line">&#125;</span><br><span class="line">hiddenDiv.addEventListener(&#x27;myCustomEvent&#x27;, function() &#123;</span><br><span class="line">  var eventData =</span><br><span class="line">  document.getElementById(&#x27;myCustomEventDiv&#x27;).innerText;</span><br><span class="line">  console.log(&#x27;收到自定义事件消息：&#x27; + eventData);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="长连接和短连接"><a href="#长连接和短连接" class="headerlink" title="长连接和短连接"></a>长连接和短连接</h3><p>chrome插件中有2种通信方式，一个是短连接（chrome.tabs.sendMessage和chrome.runtime.sendMessage），一个是长连接（chrome.tabs.connect和chrome.runtime.connect），短链接上面已经给出示例，这里对长链接给出示例：</p>
</li>
</ul>
</li>
<li><p>popup.js：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  getCurrentTabId((tabId) =&gt; &#123;</span><br><span class="line">    var port = chrome.tabs.connect(tabId, &#123;name: &#x27;test-connect&#x27;&#125;);</span><br><span class="line">    port.postMessage(&#123;question: &#x27;你是谁啊？&#x27;&#125;);</span><br><span class="line">    port.onMessage.addListener(function(msg) &#123;</span><br><span class="line">      alert(&#x27;收到消息：&#x27;+msg.answer);</span><br><span class="line">      if(msg.answer &amp;&amp; msg.answer.startsWith(&#x27;我是&#x27;))</span><br><span class="line">      &#123;</span><br><span class="line">        port.postMessage(&#123;question: &#x27;哦，原来是你啊！&#x27;&#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li><p>content-script.js：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  // 监听长连接</span><br><span class="line">chrome.runtime.onConnect.addListener(function(port) &#123;</span><br><span class="line">  console.log(port);</span><br><span class="line">  if(port.name == &#x27;test-connect&#x27;) &#123;</span><br><span class="line">    port.onMessage.addListener(function(msg) &#123;</span><br><span class="line">      console.log(&#x27;收到长连接消息：&#x27;, msg);</span><br><span class="line">      if(msg.question == &#x27;你是谁啊？&#x27;) port.postMessage(&#123;answer: &#x27;我是你爸！&#x27;&#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><p>本地存储分为两种，<code>chrome.storage</code>和html5的<code>localStorage</code>。</p>
<ul>
<li><p>localStorage<br>localStorage的两种形式：sessionStorage 和 localStorage 分别可以看成临时和永久存储：后者永久留在硬盘上，除非你在程序里remove掉，或者手动去删掉；而前者，对在chrome中而言，本地存的数据的生存时间就等于相应标签的生存时间。<br>localStorage 有 setItem, getItem, removeItem, key, clear 这5个方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">localStorage.setItem(“fresh”,“vfresh.org”); //设置一个键值</span><br><span class="line">localStorage.getItem(“fresh”); //获取一个键值</span><br><span class="line">localStorage.key(0); //获取指定下标的键的名称（如同Array）</span><br><span class="line">localStorage.removeItem(“fresh”); //删除一个键值</span><br><span class="line">localStorage.clear(); //清空storage</span><br></pre></td></tr></table></figure>
<p>注意：<br>虽然所有脚本都可以访问 localStorage 接口，但访问时仍然是基于当前的域的。也就是说 content script 们和 background script 是无法通过 localStorage 访问到同一块本地数据的！（前者域是当前浏览页面站点，后者是扩展程序自己的域“chrome://extension-id/”</p>
</li>
<li><p>chrome.storage<br>官方文档<a target="_blank" rel="noopener" href="https://developer.chrome.com/extensions/storage">chrome.storage - Google Chrome</a><br>API 为扩展程序的存储需要而特别优化，它提供了与 localStorage API 相同的能力，但是具有如下几个重要的区别：</p>
<ol>
<li>用户数据可以通过 Chrome 浏览器的同步功能自动同步（使用 storage.sync）。</li>
<li>您的扩展程序的内容脚本可以直接访问用户数据，而不需要后台页面。</li>
<li>即使使用分离式隐身行为，用户的扩展程序设置也会保留。</li>
<li>异步的，并且能够进行大量的读写操作，因此比阻塞和串行化的 localStorage API 更快。</li>
<li>用户数据可以存储为对象（localStorage API 以字符串方式存储数据）。</li>
<li>可以读取管理员为扩展程序配置的企业策略（使用 storage.managed 和架构）。</li>
</ol>
<p>但无论哪种方式，随着插件卸载，通过插件存储的数据都会被删除。</p>
<h3 id="webRequest"><a href="#webRequest" class="headerlink" title="webRequest"></a>webRequest</h3><p>官方文档<a target="_blank" rel="noopener" href="https://developer.chrome.com/extensions/webRequest">chrome.webRequest - Google Chrome</a><br>在看到插件的这一块接口时，不禁感叹插件的强大，在request的前中后均可以对其进行操作。使用该功能需要在manifest中配置权限<code>&quot;webRequest&quot;, // web请求</code>、<code>&quot;webRequestBlocking&quot;, // 阻塞式web请求</code></p>
</li>
<li><p>manifest</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//manifest.json</span><br><span class="line">&#123;</span><br><span class="line">  // 权限申请</span><br><span class="line">  &quot;permissions&quot;:</span><br><span class="line">  [</span><br><span class="line">    &quot;webRequest&quot;, // web请求</span><br><span class="line">    &quot;webRequestBlocking&quot;, // 阻塞式web请求</span><br><span class="line">    &quot;storage&quot;, // 插件本地存储</span><br><span class="line">    &quot;http://*/*&quot;, // 可以通过executeScript或者insertCSS访问的网站</span><br><span class="line">    &quot;https://*/*&quot; // 可以通过executeScript或者insertCSS访问的网站</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>background.js</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var showImage;</span><br><span class="line">chrome.storage.sync.get(&#123;showImage: true&#125;, function(items) &#123;</span><br><span class="line">  showImage = items.showImage;</span><br><span class="line">&#125;);</span><br><span class="line">// web请求监听，最后一个参数表示阻塞式，需单独声明权限：webRequestBlocking</span><br><span class="line">chrome.webRequest.onBeforeRequest.addListener(details =&gt; &#123;</span><br><span class="line">  // cancel 表示取消本次请求</span><br><span class="line">  if(!showImage &amp;&amp; details.type == &#x27;image&#x27;) return &#123;cancel: true&#125;;</span><br><span class="line">  // 简单的音视频检测</span><br><span class="line">  // 大部分网站视频的type并不是media，且视频做了防下载处理，所以这里仅仅是为了演示效果，无实际意义</span><br><span class="line">  if(details.type == &#x27;media&#x27;) &#123;</span><br><span class="line">    chrome.notifications.create(null, &#123;</span><br><span class="line">      type: &#x27;basic&#x27;,</span><br><span class="line">      iconUrl: &#x27;img/icon.png&#x27;,</span><br><span class="line">      title: &#x27;检测到音视频&#x27;,</span><br><span class="line">      message: &#x27;音视频地址：&#x27; + details.url,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, &#123;urls: [&quot;&lt;all_urls&gt;&quot;]&#125;, [&quot;blocking&quot;]);</span><br><span class="line">//blocking的意思是阻塞request，直到回调函数返回结果，从而能改变request是取消，还是重定向还是其他。</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h3><p>官方文档<a target="_blank" rel="noopener" href="https://developer.chrome.com/extensions/permissions">chrome.permissions - Google Chrome</a><br>权限在前面manifest里面已经体现了，插件和Android类似，需要使用哪些权限，需要在配置文件里申请。我们可以看到插件的权限是非常大的，可以读取你的页面输入的数据（明文数据），可以读取你存储的数据，可以任意写入，可以重定向request……</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&quot;permissions&quot;:</span><br><span class="line">	[</span><br><span class="line">		&quot;contextMenus&quot;, // 右键菜单</span><br><span class="line">		&quot;tabs&quot;, // 标签</span><br><span class="line">		&quot;notifications&quot;, // 通知</span><br><span class="line">		&quot;webRequest&quot;, // web请求</span><br><span class="line">		&quot;webRequestBlocking&quot;,</span><br><span class="line">		&quot;storage&quot;, // 插件本地存储</span><br><span class="line">		&quot;http://*/*&quot;, // 可以通过executeScript或者insertCSS访问的网站</span><br><span class="line">		&quot;https://*/*&quot; // 可以通过executeScript或者insertCSS访问的网站</span><br><span class="line">	],</span><br></pre></td></tr></table></figure>
<p>我们在安装外部插件的时候，要先看看他所获取的哪些权限，是不是有些是这个插件本不需要的。</p>
<h3 id="mac下插件安装路径"><a href="#mac下插件安装路径" class="headerlink" title="mac下插件安装路径"></a>mac下插件安装路径</h3><p>/Users/xxx/Library/Application Support/Google/Chrome/Default/Extensions</p>
<h3 id="chrome插件转Firefox插件以及safari插件"><a href="#chrome插件转Firefox插件以及safari插件" class="headerlink" title="chrome插件转Firefox插件以及safari插件"></a>chrome插件转Firefox插件以及safari插件</h3><p>这也是在项目中遇到的需求。<br><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Mozilla/Add-ons/WebExtensions">浏览器扩展 - Mozilla 产品与私有技术 | MDN</a>这是firefox的官方插件开发文档，点开一个简单示例，我们会发现和chrome的插件开发模式是基本一致。细微差别可以通过终端提示信息进行修改。<br>对于Safari，差别相对较大。safari12及以前的版本，插件的模式和chrome类似，是一个独立插件安装包，安装到浏览器即可，但是api和chrome不兼容，官方开发文档：<a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/Tools/Conceptual/SafariExtensionGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40009977-CH1-SW1">About Safari Extensions</a><br>但是Safari12之后的版本，插件作了改变，不再是一个可以直接用js和html实现的独立安装包，而是一个本地应用，应用包含了插件，也就是安装一个包含插件的本地应用，插件就默认安装了。因此需要使用objective-c等语言进行开发，而且版本12中的popover（也就是chrome重的popup）窗口，由原来的html页面变成了一个webview。相对没有ios开发基础的人来说，难度变大了。官方文档<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/safariservices/safari_app_extensions/building_a_safari_app_extension">Building a Safari App Extension | Apple Developer Documentation</a>，但是感觉并不能对开发有啥帮助。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>chrome插件除了以上功能外，还有很多其他的，比如通知、devtools扩展、右键菜单等等，除此，还有插件的打包、安装、以及发布等，这些网上可查找内容较多，不再赘述。项目结束有几个月了，才写下文档，开发过程中遇到一些问题，解决了之后，记忆已经有些模糊了。这篇文章大多参照<a target="_blank" rel="noopener" href="https://github.com/sxei/chrome-plugin-demo">GitHub - sxei/chrome-plugin-demo: 《Chrome插件开发全攻略》配套完整Demo，欢迎clone体验</a>，结合了自己的使用体验。下一篇将会介绍浏览器插件的安全。</p>
<h2 id="chrome插件安全"><a href="#chrome插件安全" class="headerlink" title="chrome插件安全"></a>chrome插件安全</h2><p>待续……</p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2020-02-23</span><i class="fa fa-tag"></i></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=,https://young.0kami.cn/2020/02/23/chrome插件开发/,yogurt,浏览器插件,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2020/06/01/%E5%9F%BA%E4%BA%8Ehyperledger%20fabric1.4%E7%9A%84%E8%B5%84%E4%BA%A7%E5%88%86%E7%B1%BB%E7%B3%BB%E7%BB%9F/" title="基于hyperledger fabric1.4的资产分类系统">Post Anterior</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2019/10/14/RoarCTF%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6writeup/" title="RoarCTF智能合约题 writeup两则">Próximo post</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>