<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author"><title>以太坊智能合约opcode分析入门 · yogurt</title><meta name="description" content="编程语言虚拟机一般有两种类型，基于栈，或者基于寄存器。和JVM一样，EVM也是基于栈的虚拟机。
既然是支持栈的虚拟机，那么EVM肯定首先得有个栈。为了方便进行密码学计算，EVM采用了32字节（256比特）的字长。EVM栈以字（Word）为单位进行操作，最多可以容纳1024个字。
和JVM一样，EVM"><meta name="keywords"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><meta name="generator" content="Hexo 5.4.0"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">yogurt</a></h3></div></div><ul class="social-links"></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a target="_blank" rel="noopener" href="https://www.caicai.me"> CaiCai </a><span>&</span><a target="_blank" rel="noopener" href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/about">关于</a></li><li><a href="/archives">归档</a></li><li><a href="/links">友链</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>以太坊智能合约opcode分析入门</a></h3></div><div class="post-content"><p>编程语言虚拟机一般有两种类型，基于栈，或者基于寄存器。和JVM一样，EVM也是基于栈的虚拟机。</p>
<p>既然是支持栈的虚拟机，那么EVM肯定首先得有个栈。为了方便进行密码学计算，EVM采用了32字节（256比特）的字长。EVM栈以字（Word）为单位进行操作，最多可以容纳1024个字。</p>
<p>和JVM一样，EVM执行的也是字节码。由于操作码被限制在一个字节以内，所以EVM指令集最多只能容纳256条指令。目前EVM已经定义了约142条指令，还有100多条指令可供以后扩展。这142条指令包括算术运算指令，比较操作指令，按位运算指令，密码学计算指令，栈、memory、storage操作指令，跳转指令，区块、智能合约相关指令等。</p>
<h2 id="一、开始"><a href="#一、开始" class="headerlink" title="一、开始"></a>一、开始</h2><p>对于智能合约的反编译，之前一直习惯使用在线的工具：<a target="_blank" rel="noopener" href="https://ethervm.io/decompile">Online Solidity Decompiler</a><br>反编译实例：</p>
<ul>
<li><p>源码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">contract test &#123;</span><br><span class="line">    uint b=1;</span><br><span class="line">    function a(uint _a) public returns (uint c)&#123;</span><br><span class="line">        c = _a+b;</span><br><span class="line">        return c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>反编译结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">contract Contract &#123;</span><br><span class="line">    function main() &#123;</span><br><span class="line">        memory[0x40:0x60] = 0x80;//分配内存256字节空间</span><br><span class="line">    </span><br><span class="line">        if (msg.data.length &lt; 0x04) &#123; revert(memory[0x00:0x00]); &#125; //判断用户调用改合约输入的data长度是否小于4，如果小于4就revert</span><br><span class="line">    </span><br><span class="line">        var var0 = msg.data[0x00:0x20] / 0x0100000000000000000000000000000000000000000000000000000000 &amp; 0xffffffff; //获取data的低4位，赋值给var0</span><br><span class="line">    </span><br><span class="line">        if (var0 != 0xf0fdf834) &#123; revert(memory[0x00:0x00]); &#125;  // `0xf0fdf834`是“test”的sha3前4位，这里如果相等，就表示用户调用的是test函数，将执行该函数</span><br><span class="line">    </span><br><span class="line">        var var1 = msg.value; </span><br><span class="line">    </span><br><span class="line">        if (var1) &#123; revert(memory[0x00:0x00]); &#125;  //msg.value如果不等于0，就退出执行，因为test函数没有payable，不需要支付费用</span><br><span class="line">    </span><br><span class="line">        var1 = 0x6c;</span><br><span class="line">        var var2 = msg.data[0x04:0x24];   //传入的参数</span><br><span class="line">        var1 = func_0082(var2);           //调用test(var2)</span><br><span class="line">        var temp0 = memory[0x40:0x60];</span><br><span class="line">        memory[temp0:temp0 + 0x20] = var1;</span><br><span class="line">        var temp1 = memory[0x40:0x60];</span><br><span class="line">        return memory[temp1:temp1 + (temp0 + 0x20) - temp1];     //返回结果var1</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function func_0082(var arg0) returns (var r0) &#123; return arg0 + storage[0x00]; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>该反编译结果实际上就是对执行逻辑的一个翻译，注释部分对代码进行了简单的解释<br>ps：使用<code>web3.sha3(&quot;a(uint256)&quot;);</code>可以计算出<code>a(uint256)</code>的签名，计算结果为<br>“0xf0fdf83467af68171df09204c0b00056c1e4c80e368b3fff732778b858f7966d”，之后取前四字节”f0fdf834”作为a(uint256)函数的签名。</p>
</li>
</ul>
<p>但是并不是每一次使用该在线反编译工具都是这个顺利的，某一次这个网站502了，突然意识到本地的逆向工具很重要，而且有时候会遇到在线反编译报错的情况，所以用ida安装了合约逆向的插件：<a target="_blank" rel="noopener" href="https://github.com/crytic/ida-evm">GitHub - crytic/ida-evm: IDA Processor Module for the Ethereum Virtual Machine (EVM)</a><br>但是ida逆向的结果和在线的Decompiler还是有差别的，在线的Decompiler反编译出来会有伪代码，比较容易理解，ida反编译的是opcode，无奈，只好去学习一下opcode相关内容。</p>
<h2 id="二、简单了解opcode"><a href="#二、简单了解opcode" class="headerlink" title="二、简单了解opcode"></a>二、简单了解opcode</h2><p><code>PUSH1 0x60 PUSH1 0x40 MSTORE</code></p>
<ul>
<li>PUSH1 (0x60): put 0x60 in the stack.</li>
<li>PUSH1 (0x40): put 0x40 in the stack.</li>
<li>MSTORE (0x52): allocate 0x60 of memory space and move to the 0x40 position.</li>
</ul>
<p>实际上“6060604052”通常是在合约的开头，简而言之，“PUSH1 0x60 PUSH1 0x40 MSTORE”正在做的是分配96个字节的存储器并将指针移动到第64个字节的开头。 我们现在有64个字节用于临时空间，32个字节用于临时存储器存储。</p>
<p>EVM里有三种存储方式：</p>
<ul>
<li>stack  “PUSH”命令</li>
<li>memory 用“MSTORE”指令</li>
<li>stroage 用“SSTORE”指令存储数据，类似于存储在硬盘上，最耗费gas的存储<br>针对这三种存储方式，展开又有一些内容了，</li>
</ul>
<h2 id="三、从solc编译过程来理解solidity合约结构-安全客，安全资讯平台"><a href="#三、从solc编译过程来理解solidity合约结构-安全客，安全资讯平台" class="headerlink" title="三、从solc编译过程来理解solidity合约结构 - 安全客，安全资讯平台"></a>三、<a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/164567">从solc编译过程来理解solidity合约结构 - 安全客，安全资讯平台</a></h2><p><strong>实例合约</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.24;</span><br><span class="line"></span><br><span class="line">    contract test &#123;</span><br><span class="line"></span><br><span class="line">        function a() &#123;</span><br><span class="line">            uint a = 123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>通过remix上编译返回的Runtime Bytecode字节码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">000 PUSH1 80</span><br><span class="line">002 PUSH1 40</span><br><span class="line">004 MSTORE             ;  把0x80 写到[0x40 ,0x40 + 0x20] 这块内存里面,因为内存是空的,这会创建新的内存</span><br><span class="line">005 PUSH1 04</span><br><span class="line">007 CALLDATASIZE       ;  获取CALLDATA 的长度</span><br><span class="line">008 LT                 ;  LT 和PUSH1 0x4 对应,判断CALLDATA 的长度是否小于0x4</span><br><span class="line">009 PUSH1 3f</span><br><span class="line">011 JUMPI              ;  如果小于0x4 就往下跳转到0x3F</span><br><span class="line">012 PUSH1 00</span><br><span class="line">014 CALLDATALOAD       ;  CALLDATALOAD 0x0 ,PUSH1 0x0 是给CALLDATALOAD 的参数,意思要获取CALLDATA 数据的偏移位置</span><br><span class="line">015 PUSH29 0100000000000000000000000000000000000000000000000000000000</span><br><span class="line">045 SWAP1</span><br><span class="line">046 DIV                ;  DIV 和PUSH29 对应,意思是把上面的数据向左移28 字节,剩下4 字节是调用合约函数名的哈希</span><br><span class="line">047 PUSH4 ffffffff</span><br><span class="line">052 AND                ;  AND 和PUSH4 0xFFFFFFFF 对应,保留低位4 字节数据,高位去处</span><br><span class="line">053 DUP1</span><br><span class="line">054 PUSH4 0dbe671f     ;  这个是合约有的函数名,经过sha3() 精简过的</span><br><span class="line">059 EQ                 ;  判断传递过来的函数调用名是否相等</span><br><span class="line">060 PUSH1 44</span><br><span class="line">062 JUMPI              ;  如果两值相等就往下跳转到0x44</span><br><span class="line">063 JUMPDEST           ;  空指令</span><br><span class="line">064 PUSH1 00</span><br><span class="line">066 DUP1</span><br><span class="line">067 REVERT             ;  没有匹配到相应的函数就撤销所有操作,Revert(0,0)</span><br><span class="line">068 JUMPDEST</span><br><span class="line">069 CALLVALUE          ;  获取用户转帐数额</span><br><span class="line">070 DUP1</span><br><span class="line">071 ISZERO             ;  如果用户转帐数额为0</span><br><span class="line">072 PUSH1 4f</span><br><span class="line">074 JUMPI              ;  转帐数额不为0 则跳到0x4F,否则就退出</span><br><span class="line">075 PUSH1 00</span><br><span class="line">077 DUP1</span><br><span class="line">078 REVERT             ;  因为调用函数a() 是不需要附加转帐金额的,所以检测到带有附加金额的函数调用就退出,参考payable 关键字</span><br><span class="line">079 JUMPDEST</span><br><span class="line">080 POP</span><br><span class="line">081 PUSH1 56</span><br><span class="line">083 PUSH1 58</span><br><span class="line">085 JUMP               ;  跳转到地址88</span><br><span class="line">086 JUMPDEST</span><br><span class="line">087 STOP               ;  停止执行</span><br><span class="line">088 JUMPDEST</span><br><span class="line">089 PUSH1 00</span><br><span class="line">091 PUSH1 7b</span><br><span class="line">093 SWAP1</span><br><span class="line">094 POP</span><br><span class="line">095 POP</span><br><span class="line">096 JUMP               ;  跳转到地址86</span><br><span class="line">097 STOP</span><br><span class="line">----  合约代码结束分界线  ----</span><br><span class="line">098 LOG1</span><br><span class="line">099 PUSH6 627a7a723058</span><br><span class="line">106 SHA3</span><br><span class="line">107 MUL</span><br><span class="line">108 PUSH15 5fd8c2f6fe4103dba9baf9c48c052e</span><br><span class="line">124 CALLDATALOAD</span><br><span class="line">125 INVALID</span><br><span class="line">126 PUSH1 d9</span><br><span class="line">128 INVALID</span><br><span class="line">129 INVALID</span><br><span class="line">130 TIMESTAMP</span><br><span class="line">131 STATICCALL</span><br><span class="line">132 INVALID</span><br><span class="line">133 INVALID</span><br><span class="line">134 DUP13</span><br><span class="line">135 INVALID</span><br><span class="line">136 TIMESTAMP</span><br><span class="line">137 INVALID</span><br><span class="line">138 NUMBER</span><br><span class="line">139 STOP</span><br><span class="line">140 INVALID</span><br></pre></td></tr></table></figure>

<ul>
<li>函数运算过程</li>
</ul>
<p><img src="https://raw.githubusercontent.com/n0pn0pn0p/n0pn0pn0p.github.io/master/myimages/01221030_Z6Do.png" alt="01221030_Z6Do的副本.png"></p>
<h2 id="四、remix动态调试"><a href="#四、remix动态调试" class="headerlink" title="四、remix动态调试"></a>四、remix动态调试</h2><p>remix（<a target="_blank" rel="noopener" href="https://remix.ethereum.org/#optimize=false&version=soljson-v0.4.24+commit.e67f0147.js&evmVersion=null">Remix - Ethereum IDE</a>）提供了动态调试的功能</p>
<p>点击左侧的debug图标，输入合约的交易hash，点击<code>start debugging</code></p>
<p><img src="https://raw.githubusercontent.com/n0pn0pn0p/n0pn0pn0p.github.io/master/myimages/d00ba0e8.png" alt="d00ba0e8.png"></p>
<p>同态调试时会展示opcode，stack、storage以及memory的值。</p>
<p><img src="https://raw.githubusercontent.com/n0pn0pn0p/n0pn0pn0p.github.io/master/myimages/e30468bd.png" alt="e30468bd.png"></p>
<h2 id="五、小结"><a href="#五、小结" class="headerlink" title="五、小结"></a>五、小结</h2><p>因为这个合约本身比较简单，所以在调试过程中会感觉比较容易。分析opcode，会发现有很多看似多余的代码，不理解其意思，后续还需要多练习，以及阅读solidity的编译器源码(<a target="_blank" rel="noopener" href="https://github.com/ethereum/solidity">GitHub - ethereum/solidity: Solidity, the Contract-Oriented Programming Language</a>)以及以太坊中evm的实现(<a target="_blank" rel="noopener" href="https://github.com/ethereum/go-ethereum/blob/master/core/vm">go-ethereum/core/vm at master · ethereum/go-ethereum · GitHub</a>)。</p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2019-09-12</span><i class="fa fa-tag"></i><a class="tag" href="/tags/区块链/" title="区块链">区块链 </a></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=,https://young.0kami.cn/2019/09/12/以太坊智能合约opcode分析入门/,yogurt,以太坊智能合约opcode分析入门,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2019/09/19/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6opcode%E5%88%86%E6%9E%90%E5%85%A5%E9%97%A8%20partII/" title="以太坊智能合约opcode分析入门 partII">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2019/01/23/constantinople-reentrancy%20attack%20%E5%A4%8D%E7%8E%B0/" title="constantinople-reentrancy attack 复现">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>